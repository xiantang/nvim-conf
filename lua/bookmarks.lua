-- local M = {}
-- local Snacks = require("snacks")
-- local Path = require("plenary.path")
--
-- M.bookmarks = {}
-- M.extmarks = {}
-- M.namespace = vim.api.nvim_create_namespace("bookmarks")
--
-- local function get_bookmark_file()
-- 	local project_root = vim.fn.getcwd()
-- 	local project_name = vim.fn.fnamemodify(project_root, ":t")
-- 	local cache_dir = vim.fn.stdpath("cache")
-- 	return Path:new(cache_dir, "nvim_bookmarks", project_name .. "_bookmarks.json")
-- end
--
-- local function save_bookmarks()
-- 	local bookmark_file = get_bookmark_file()
-- 	bookmark_file:parent():mkdir({ parents = true, exists_ok = true })
-- 	bookmark_file:write(vim.fn.json_encode(M.bookmarks), "w")
-- end
--
-- local function load_bookmarks()
-- 	local bookmark_file = get_bookmark_file()
-- 	if bookmark_file:exists() then
-- 		local content = bookmark_file:read()
-- 		M.bookmarks = vim.fn.json_decode(content)
-- 	else
-- 		M.bookmarks = {}
-- 	end
-- end
--
-- local function set_extmark(bufnr, line, note)
-- 	local id = vim.api.nvim_buf_set_extmark(bufnr, M.namespace, line - 1, -1, {
-- 		virt_text = { { "ğŸ”– " .. note, "Comment" } },
-- 		virt_text_pos = "eol",
-- 	})
-- 	table.insert(M.extmarks, { id = id, bufnr = bufnr })
-- end
--
-- local function update_virtual_text()
-- 	-- æ¸…é™¤æ‰€æœ‰æ—§çš„ extmarks
-- 	for _, extmark in pairs(M.extmarks) do
-- 		pcall(vim.api.nvim_buf_del_extmark, extmark.bufnr, M.namespace, extmark.id)
-- 	end
-- 	M.extmarks = {}
--
-- 	-- ä¸ºæ¯ä¸ªæ‰“å¼€çš„ç¼“å†²åŒºæ·»åŠ æ–°çš„ virtual text
-- 	for _, buf in ipairs(vim.api.nvim_list_bufs()) do
-- 		if vim.api.nvim_buf_is_loaded(buf) then
-- 			local file = vim.api.nvim_buf_get_name(buf)
-- 			for _, bookmark in pairs(M.bookmarks) do
-- 				if bookmark.file == file then
-- 					set_extmark(buf, bookmark.line, bookmark.note)
-- 				end
-- 			end
-- 		end
-- 	end
-- end
--
-- function M.toggle_bookmark()
-- 	load_bookmarks()
-- 	local file = vim.fn.expand("%:p")
-- 	local line = vim.fn.line(".")
-- 	local key = file .. ":" .. line
--
-- 	if M.bookmarks[key] then
-- 		M.bookmarks[key] = nil
-- 	else
-- 		vim.ui.input({ prompt = "Enter bookmark note: " }, function(note)
-- 			if note then
-- 				M.bookmarks[key] = { file = file, line = line, note = note }
-- 			end
-- 		end)
-- 	end
-- 	save_bookmarks()
-- 	update_virtual_text()
-- end
--
-- function M.apply_buffer_virtual_text()
-- 	for _, extmark in pairs(M.extmarks) do
-- 		pcall(vim.api.nvim_buf_del_extmark, extmark.bufnr, M.namespace, extmark.id)
-- 	end
--
-- 	local current_file = vim.fn.expand("%:p")
-- 	local bufnr = vim.api.nvim_get_current_buf()
--
-- 	-- è·å–å½“å‰ç¼“å†²åŒºçš„æ‰€æœ‰ extmarks
-- 	local existing_extmarks = vim.api.nvim_buf_get_extmarks(bufnr, M.namespace, 0, -1, { details = true })
-- 	local extmark_lines = {}
--
-- 	-- åˆ›å»ºä¸€ä¸ªæŸ¥æ‰¾è¡¨ï¼Œç”¨äºå¿«é€Ÿæ£€æŸ¥è¡Œæ˜¯å¦å·²æœ‰ extmark
-- 	for _, extmark in ipairs(existing_extmarks) do
-- 		extmark_lines[extmark[2] + 1] = true -- extmark è¡Œå·ä» 0 å¼€å§‹ï¼Œæ‰€ä»¥è¦ +1
-- 	end
--
-- 	for _, bookmark in pairs(M.bookmarks) do
-- 		if bookmark.file == current_file then
-- 			-- æ£€æŸ¥è¯¥è¡Œæ˜¯å¦å·²ç»æœ‰ extmark
-- 			if not extmark_lines[bookmark.line] then
-- 				set_extmark(bufnr, bookmark.line, bookmark.note)
-- 			end
-- 		end
-- 	end
-- end
--
-- function M.list_bookmarks()
-- 	load_bookmarks()
-- 	local bookmark_list = {}
-- 	for _, bookmark in pairs(M.bookmarks) do
-- 		local line = tonumber(bookmark.line)
-- 		local display_path = vim.fn.fnamemodify(bookmark.file, ":~:.")
-- 		table.insert(bookmark_list, {
-- 			file = bookmark.file,
-- 			line = line,
-- 			note = bookmark.note,
-- 			text = string.format("%s %s:%d", bookmark.note, display_path, line),
-- 			display_path = display_path,
-- 			pos = { line, 0 },
-- 		})
-- 	end
--
-- 	Snacks.picker.pick("bookmarks", {
-- 		title = "Bookmarks",
-- 		items = bookmark_list,
-- 		format = function(item)
-- 			return {
-- 				{ item.note or "", "Title" },
-- 				{ "  " .. item.display_path .. ":" .. item.line, "Comment" },
-- 			}
-- 		end,
-- 		preview = "preview",
-- 		confirm = function(picker, item)
-- 			picker:close()
-- 			if not item or not item.file then
-- 				return
-- 			end
-- 			vim.cmd("edit " .. vim.fn.fnameescape(item.file))
-- 			vim.api.nvim_win_set_cursor(0, { item.line, 0 })
-- 			vim.schedule(M.apply_buffer_virtual_text)
-- 		end,
-- 	})
-- end
--
-- function M.setup()
-- 	load_bookmarks()
-- 	update_virtual_text()
--
-- 	--abc
-- 	vim.cmd([[
--         augroup Bookmarks
--             autocmd!
--             autocmd BufRead * lua require('bookmarks').apply_buffer_virtual_text()
--             autocmd BufEnter * lua require('bookmarks').apply_buffer_virtual_text()
--             autocmd BufWritePost * lua require('bookmarks').apply_buffer_virtual_text()
--         augroup END
--     ]])
--
-- 	vim.api.nvim_set_keymap(
-- 		"n",
-- 		"<leader>mm",
-- 		'<cmd>lua require("bookmarks").toggle_bookmark()<CR>',
-- 		{ noremap = true, silent = true }
-- 	)
-- 	vim.api.nvim_set_keymap(
-- 		"n",
-- 		"<leader>ml",
-- 		'<cmd>lua require("bookmarks").list_bookmarks()<CR>',
-- 		{ noremap = true, silent = true }
-- 	)
-- end
--
-- return M
